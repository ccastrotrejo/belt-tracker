/**
 * Compute the start of the week (Monday) for a given date. Weeks are defined
 * according to ISO conventions where Monday is the first day of the week. The
 * returned value is a timestamp at midnight UTC for the start of the week.
 *
 * @param {Date|string} date - A Date object or a string that can be
 *   converted to a Date.
 * @returns {number} A timestamp (milliseconds since epoch) representing the
 *   Monday of the week containing the given date.
 */
export function getWeekStart(date) {
  const d = new Date(date);
  // getDay returns 0 for Sunday, 1 for Monday, etc. We want Monday as
  // the first day of the week. If d.getDay() is 0 (Sunday), we move back 6 days;
  // otherwise we move back (getDay() - 1) days.
  const day = d.getDay();
  const diff = d.getDate() - day + (day === 0 ? -6 : 1);
  const monday = new Date(d);
  monday.setDate(diff);
  monday.setHours(0, 0, 0, 0);
  return monday.getTime();
}

/**
 * Generate weekly counts of office visits for the last twelve weeks. The
 * function returns an array of objects, each containing the timestamp for the
 * start of the week and the count of entries for that week. Weeks with no
 * entries are included with a count of zero. The result is sorted chronologically.
 *
 * @param {Array<{ date: string }> } entries - An array of entry objects. Each
 *   entry must have a `date` property (ISO string or Date parsable).
 * @returns {Array<{ weekStart: number, count: number }> } Weekly counts for the
 *   last twelve weeks. The array has length 12.
 */
export function computeWeeklyCounts(entries) {
  const now = new Date();
  // Determine the Monday of this week
  const currentWeekStart = getWeekStart(now);
  // Initialise counts for last 12 weeks
  const weeks = {};
  for (let i = 0; i < 12; i++) {
    const start = new Date(currentWeekStart - i * 7 * 24 * 3600 * 1000);
    start.setHours(0, 0, 0, 0);
    weeks[start.getTime()] = 0;
  }
  // Count entries per week
  entries.forEach((entry) => {
    const weekKey = getWeekStart(entry.date);
    if (weekKey in weeks) {
      weeks[weekKey] += 1;
    }
  });
  // Convert to array and sort ascending by week start
  return Object.keys(weeks)
    .map((key) => ({ weekStart: parseInt(key, 10), count: weeks[key] }))
    .sort((a, b) => a.weekStart - b.weekStart);
}

/**
 * Compute the BELT average given an array of weekly counts. The BELT
 * average is defined as the average of the eight highest weekly values. If
 * fewer than eight weeks contain nonâ€‘zero data, all available weeks are used.
 *
 * @param {Array<{ weekStart: number, count: number }> } weeklyCounts - The
 *   weekly counts generated by computeWeeklyCounts.
 * @returns {number} The BELT average (mean of the highest eight counts).
 */
export function computeBeltAverage(weeklyCounts) {
  const counts = weeklyCounts.map((w) => w.count);
  const sorted = counts.slice().sort((a, b) => b - a);
  const n = Math.min(8, sorted.length);
  if (n === 0) return 0;
  const sum = sorted.slice(0, n).reduce((acc, val) => acc + val, 0);
  return sum / n;
}

/**
 * Compute the number of extra days needed to maintain a given target BELT
 * average if the user plans to skip a specific week. The function simulates
 * adding a zero count for the skipped week, recomputes the BELT average,
 * and determines the difference between the required sum of the top eight
 * weeks and the current sum. The result is rounded up to the nearest
 * whole number because partial days are not meaningful.
 *
 * @param {Array<{ weekStart: number, count: number }> } weeklyCounts - The
 *   current weekly counts.
 * @param {number} target - The desired BELT average (e.g. 3 days/week).
 * @param {Date} skipDate - A Date representing the first day of the week
 *   to skip. Only the week is relevant, not the specific day.
 * @returns {number} The minimum number of additional days required in
 *   previous weeks to maintain the target BELT average. Returns 0 if no
 *   additional days are necessary.
 */
export function computeRequiredDays(weeklyCounts, target, skipDate) {
  // Clone current counts and append a zero for the skipped week
  const counts = weeklyCounts.map((w) => w.count);
  counts.push(0);
  const sorted = counts.slice().sort((a, b) => b - a);
  const n = Math.min(8, sorted.length);
  if (n === 0) return 0;
  const currentSum = sorted.slice(0, n).reduce((acc, val) => acc + val, 0);
  const requiredSum = target * n;
  const deficit = requiredSum - currentSum;
  return deficit <= 0 ? 0 : Math.ceil(deficit);
}
